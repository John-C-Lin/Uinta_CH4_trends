# Creates gridded information of well numbers and well production that can be convolved with 
# STILT footprints to quantitatively relate wells to receptors
# V2(210404): since fluxes are in [umole/m2/s], need to divide well quantities by area of footprint gridcell to cancel out [m-2] and number of days in a month to cancel out [s-1]
# March 22nd, 2021 by John C. Lin (John.Lin@utah.edu)

######################
datname <- "State_of_Utah_oil_gas_DATA/well_data_gas.oil.production_monthly.rds" # generated by 'State_of_Utah_oil_gas_DATA/merge_well_data_production.r'
# Months and Years to grid
MMs <- formatC(1:12,flag="0",width=2)
YYYYs <- 2015:2020
YYYYMMs <- paste0(rep(YYYYs,each=length(MMs)),rep(MMs,length(YYYYs)))
# where footprints are stored
outputdir<-paste0("/uufs/chpc.utah.edu/common/home/lin-group7/jcl/CH4_inversion/CH4_inversion_Uintah/CH4_inversion_Uintah_HYSPLIT-STILT/out/HPL/by-id/")
plotTF <- FALSE
######################

require(ncdf4);require(fields)
require(maps);require(RgoogleMaps)
require(geosphere)

DAT <- readRDS(datname)

# Footprint grid settings from 'run_stilt_hysplit-stiltV1.r'
xmn <- -112.5; xmx <- -108
ymn <- 38.5; ymx <- 41.5
xres <- 0.01; yres <- xres

# read in sample footprint to get footprint dimensions
YYYYMMDDs <- list.files(outputdir,pattern="201604")[1]
ncfilenm <- paste0(outputdir,"/",YYYYMMDDs[1],"/",YYYYMMDDs[1],"_foot.nc")
if(!file.exists(ncfilenm))stop(paste("no footprint output for:",ncfilenm))
# Generate footprint
footfile <- nc_open(ncfilenm); foot.all <- ncvar_get(footfile,"foot")
footsum <- apply(foot.all,c(1,2),sum)   #sum over back times
flat <- ncvar_get(footfile,"lat");flon <- ncvar_get(footfile,"lon")
# lat/lons refer to footprint grid CENTERS, so move them to lower left (southwest) corner to facilitate gridding
flat.ll <- flat - yres/2; flon.ll <- flon - xres/2

# determine footprint gridcell areas
flon.vec <- rep(flon,ncol(footsum))
flat.vec <- rep(flat,each=nrow(footsum))
dx <- distHaversine(p1=cbind(flon.vec,flat.vec),p2=cbind(flon.vec+xres,flat.vec))
dy <- mean(distHaversine(p1=cbind(flon.vec,flat.vec),p2=cbind(flon.vec,flat.vec+yres)))   # gridcell dimension in y-direction is almost a constant
AREA <- dx*dy  # gridcell area [m^2]
AREA.mat <- matrix(AREA,nrow=length(flon)) #; image.plot(AREA.mat)

# map well lat/lon to footprint grid index
foot.iy <- floor((DAT$Latitude - ymn)/yres) + 1
foot.ix <- floor((DAT$Longitude - xmn)/yres) + 1
DAT <- data.frame(DAT,foot.iy,foot.ix)

# I.  SUM total production in each footprint grid
vars <- c("Mcf.Gas","Bbls.Oil")
for(vv in 1:length(vars)){
  var <- vars[vv]
  result <- array(data=0, dim=c(length(flon),length(flat),length(YYYYMMs)))
  dimnames(result) <- list(flon, flat, YYYYMMs)
  print(paste("Processing: ",var,"......"))
for(i in 1:length(YYYYMMs)){
  YYYYMM <- YYYYMMs[i]
  sel <- substring(DAT$YYYYMMDD,1,6) == YYYYMM
  dat <- DAT[sel,]
  print(paste0(YYYYMM,"; Max # of days in month: ",max(dat$Days.Prod,na.rm=T)))
  ind <- paste0(dat$foot.ix,",",dat$foot.iy)
  xsum <- tapply(dat[,var],ind,sum)
  tmp <- strsplit(names(xsum),",")
  inds.mat <- matrix(as.numeric(unlist(tmp)),byrow=T,ncol=2)
  result[,,i][inds.mat] <- xsum
  result[,,i] <- result[,,i]/AREA.mat   # normalize by gridcell area [m^2]
  result[,,i] <- result[,,i]/max(dat$Days.Prod,na.rm=T)   # normalize by number of days in month 
  gc()
} #for(i in 1:length(YYYYMMs)){
  resultname <- paste0(var,"_gridded.rds")
  saveRDS(result,resultname)
  print(paste(resultname,"generated"))
  gc()
} #for(vv in 1:length(vars)){

# II.  TALLY total well numbers of different types in each footprint grid
vars <- c("Gas Well","Oil Well","Unlabelled","Gas Well:Producing","Oil Well:Producing")[-3]
for(vv in 1:length(vars)){
  var <- vars[vv]
  result <- array(data=0, dim=c(length(flon),length(flat),length(YYYYMMs)))
  dimnames(result) <- list(flon, flat, YYYYMMs)
  print(paste("Processing: ",var,"......"))
for(i in 1:length(YYYYMMs)){
  YYYYMM <- YYYYMMs[i]
  sel <- substring(DAT$YYYYMMDD,1,6) == YYYYMM
  if(sum(sel)==0){print(paste("No data:",YYYYMM,"; skip"));next}
  dat <- DAT[sel,]
  if(var%in%c("Gas Well","Oil Well","Unlabelled")){
    var2 <- var
    if(var=="Unlabelled")var2 <- ""
    sel <- dat$Well.Type.x == var2
    if(sum(sel)==0){print(paste("No data:",YYYYMM,"; ",var2,"skip"));next}
    dat <- dat[sel,]
  } else {
    sel <- paste0(dat$Well.Type.x,":",dat$Well.Status.x)==var
    dat <- dat[sel,]
  } #if(){
  ind <- paste0(dat$foot.ix,",",dat$foot.iy)
  N <- tapply(ind,ind,length)
  tmp <- strsplit(names(N),",")
  inds.mat <- matrix(as.numeric(unlist(tmp)),byrow=T,ncol=2)
  result[,,i][inds.mat] <- N
  result[,,i] <- result[,,i]/AREA.mat   # normalize by gridcell area [m^2]
  result[,,i] <- result[,,i]/max(dat$Days.Prod,na.rm=T)   # normalize by number of days in month 
  print(paste(YYYYMM,var,": sum(N)=",sum(N),"; max # of days in month:",max(dat$Days.Prod,na.rm=T)))
  gc()
} #for(i in 1:length(YYYYMMs)){
  if(length(grep(":",var)))  var <- gsub(":","_",var)
  resultname <- paste0(gsub(" ",".",var),"_gridded.rds")
  saveRDS(result,resultname)
  print(paste(resultname,"generated"))
  gc()
} #for(vv in 1:length(vars)){


# tally number of oil and gas producing wells
gas <- readRDS("Gas.Well_Producing_gridded.rds")
oil <- readRDS("Oil.Well_Producing_gridded.rds")
gas <- gas[,,"202009"]*AREA.mat
oil <- oil[,,"202009"]*AREA.mat
gas <- gas*30   # multiply by number of days in month
oil <- oil*30   # multiply by number of days in month
print(paste("Total of:",sum(gas),"natural gas producing wells\n",sum(oil),"oil producing wells"))



if(plotTF){
  var <- "Mcf.Gas"
  #var <- "Bbls.Oil"
  resultname <- paste0(var,"_gridded.rds")
  dat.all <- readRDS(resultname)

  # time series per year
  dat <- apply(dat.all,c(3),sum)
  dev.new()
  YYYY <- as.numeric(substring(names(dat),1,4))
  MM <- as.numeric(substring(names(dat),5,6))
  plot(YYYY+(MM-1)/12,dat,pch=16,type="o",xlab="Year",ylab=var)

  i <- 65
  dev.new()
  image.plot(x=flon,y=flat,z=dat.all[,,i],main=paste(var,"\n",dimnames(dat.all)[[3]][i]))

} #if(plotTF){


